<header>
	<h3>Циклы</h3>
</header>
<h4>Использование for </h4>
<p>Составить программу для проверки утверждения: «Результатами вычислений по формуле х<sup>2</sup> + х + 41  при 0 <= х <= 40 являются простые числа&raquo;. Все результаты вывести на экран.</p>
<p>Если не знаем, что такое простые числа, открываем поисковую систему yandex или google и пишем эти два слова. Находится так же легко как и все остальное.</p>
<p>Если знаем, то вспоминаем, что это число которое делится без остатка только на 1 и на само себя.</p>
<p>Для организации цикла можно использовать операторы <b>for</b> или <b>while</b></p>
<pre>
<b>function</b> <u title="Проверка простых чисел">checkSimpleNumber</u>() {
	<span class="strcolor">"use strict"</span>
	<b>var</b> s = <span class="strcolor">''</span>, x = 0, n, j, ctrl1, ctrl2;
	<b>for</b> (x; x <= 40; x = x + 1) {
		n = x*x + x + 41;
		<b>for</b> (j = 2; j < n; j++) {
			ctrl1 = n / j;
			ctrl2 = <b>Math</b>.<i title="Округление вниз, то есть floor(3.9) вернет 3">floor</i>(ctrl1);
			<b>if</b> (ctrl1 == ctrl2) {
				<u>writeln</u>(<span class="strcolor">"При x = "</span> + x + <span class="strcolor">" получаем непростое число n = "</span> + n + <span class="strcolor">", делящееся без остатка на "</span> + j + <span class="strcolor">". Утверждение неверно!"</span>);
				<b>return</b>;
			}
		}
		s += n + <span class="strcolor">' '</span>;
		<b>if</b> (x % 5 == 0 && x !== 0) {
			s += <span class="strcolor">'\n'</span>;
		}
	}
	<u>writeln</u>(s);
}
</pre>
<p>Итак, что здесь происходит. Я использовал цикл <b>for</b>. Если вы внимательно прочтете подсказку к этому ключевому слову, вы поймете что тело цикла будет выполнено 41 раз, при этом переменная x будет принимать значения от 0 до 40.</p>
<p>Новички могут пойматься, записав определение цикла <b>for</b> (x; x < 40; x = x + 1) </p>
<p>В этом случае действительно все полученные числа будут простыми, вот только не выполнится условие из текста задачи: икс должен изменяться от 0 до 40, включая 0 и 40. А при x = 40 мы получаем по данной в задаче формуле число, которое делится на 41 без остатка.</p>
<p>Посмотрим подробнее, как я проверяю, что число простое или не простое. Самый простой способ - это попробовать разделить полученное по формуле число n на все значения от 2 (на единицу простое число делится без остатка) до n, не включая n, так как на само себя простое число делится также без остатка. 
Я делаю это во втором цикле. Вы можете видеть, что в нем я использую для увеличения j конструкцию j++, в то время как в первом (внешнем) цикле я использую x = x + 1. <b class="tblack">При использовании в цикле</b> <b>for</b> эти конструкции по смыслу вполне эквивалентны. j++ увеличивает значение переменной j на единицу всякий раз после того, как тело цикла выполнено. Одно такое выполнение тела цикла называется <b class="tblack">итерацией</b>.</p>
<div class="ainfo">
	Если стало интересно, почему я подчеркнул, что j++  и j = j + 1 эквивалентны только при использовании в цикле for, внимательно прочитайте комментарии к коду и выполните код:
<pre>
<b>function</b> <u title="Поведение ++">plusPlusBehavior</u>() {
	<b>var</b> a, d, b = 1, c = 1;
	a = b++;<span class="strcolor">//Записали в a значение b, после чего увеличили b на единицу 
</span>	d = ++c;<span class="strcolor">//увеличили c на единицу, после чего записали в d значение c
</span>	<u>writeln</u>(<span class="strcolor">'a = '</span> + a + <span class="strcolor">', b = '</span> + b + <span class="strcolor">', c = '</span> + c + <span class="strcolor">', d = '</span> + d);
}
</pre>
</div>
<p>В каждой итерации внутреннего цикла я делю полученное во внешнем цикле число n на j, после чего передаю результат методу объекта Math.floor. Этот метод отбрасывает дробную часть, если она есть. Сравнив результат его работы с частным n / j я могу понять, делилось n  на j без остатка или нет.
Если это так, значит я вывожу сообщение и завершаю работу программы, используя оператор <b>return</b>.</p>
<p>Иначе я продолжаю собирать полученные значения n в строку s, ведь мне надо вывести все простые числа если утверждение истинно.</p>
<p>Через каждые пять итераций я добавляю символ новой строки \n, чтобы вывести эти числа компактно: восемь строк по пять цифр. Вы можете это видеть, если временно измените условный оператор внешнего цикла с <= на <. 
Для отсчета этих пяти итераций я использую операцию получения остатка от целочисленного деления %. Например, 12 % 10 равно двум (частное 1, остаток 2)</p>
<h4>Использование while </h4>
<p>В предыдущем примере вполне можно было бы использовать <b>while</b> вместо <b>for</b>. Внешний цикл выглядел бы тогда: 
<pre><b>while</b>(x <= 40) {
	//...
	x++;
}</pre>
а суть осталось той же. То же касается и внутреннего цикла. Я буду использовать <b>while</b> в следующем примере.
</p>
<p>Вычислить</p>
<?=QuickStartHandler::tim(24, 3, 2) ?>
<p>при a не равном 1</p>
<pre>
<b>function</b> <u title="Конечная сумма. Лучшего названия для этой функции я выдумать не смог %-(">endingSum</u>() {
	<span class="strcolor">"use strict"</span>
	<b>var</b> a = <i>parseInt</i>( <u>readln</u>(<span class="strcolor">'Введите a'</span>) ),
		sum = 1 / a, n = 2, prevSum = sum;
	<b>if</b>(<i>isNaN</i>(a) || a == 1 ) {<span class="strcolor">//если a не число или равен 1
</span>		<u>writeln</u>(<span class="strcolor">'a должно быть числом не равным 1!'</span>);
		<b>return</b>;
	}
	<b>while</b> (<b>true</b>) {
		sum += 1 / Math.<i>pow</i>(a, 2 * n - 2);
		n++;
		<b>if</b> (sum == prevSum) {
			<b>break</b>;
		}
		prevSum = sum;
	}
	<u>writeln</u>(sum);
}
</pre>
<p>От нас требуют найти сумму членов последовательности, каждый член которой, за исключением первого, вычисляется по формуле единица деленная на (а в степени 2*n - 2). При этом n равно номеру слагаемого, при нумерации их с единицы. Понятно, что чем больше n, тем больше делитель очередного слагаемого. Если вспомнить пределы последовательностей и функций, можно сказать, что делитель стремится к бесконечности, при n стремящемся к бесконечности.</p>
<p>Еще можно вспомнить, что единица, деленная на бесконечность равна нулю.</p>
<p>Решение этой задачи на языке JavaScript облегчается тем, что числовая переменная в JavaScript может принимать специальное значение <b>Infinity</b> - бесконечность.</p>
<p>И если мы попытаемся разделить единицу на переменную, содержащую это значение, мы получим ноль, как и положено в математическом анализе.</p>
<p>Следующий простой код позволит убедиться, что это действительно так:</p>
<pre>
<b>function</b> infinityExample() {
	<span class="strcolor">"use strict"</span>
	<b>var</b> n = 1 / 0; <span class="strcolor">//Получили бесконечность
</span>	<u>writeln</u>(<span class="strcolor">'n = '</span> + n); <span class="strcolor">//Убедились, что это так
</span>	<u>writeln</u>(<span class="strcolor">'1 / n = '</span> + (1 / n)); <span class="strcolor">//Убедились, что единица деленная на бесконечность равна  0
</span>}
</pre>
<p>Итак, я вправе ожидать, что по мере роста n делитель очередного слагаемого станет равен бесконечности, а значит сумма перестанет расти.</p>
<p>В коде примера endingSum я получаю от пользователя значение a и контролирую, не равен ли он нулю или единице.</p>
<p>Далее, инициализую переменную, в которой буду накапливать сумму, значением первого члена последовательности, n присваиваю значение 2, так как меня интересуют члены последовательности от второго и дальше. Также, я объявляю переменную prevSum, в которой буду хранить значение предыдущей суммы. Используя эту переменную я смогу понять, что сумма перестала расти, значит, можно прекращать вычисления.</p>
<p>Для организации цикла я использовал слово <b>while</b>. Этот цикл будет выполняться, пока логическое выражение в круглых скобках после <b>while</b> будет равно <b>true</b>. Но мне ничего не мешает вместо выражения поместить в эти круглые скобки значение <b>true</b>, объявив таким образом бесконечный цикл.</p>
<p>Такая практика несколько рискована, так как есть опасность, что цикл действительно никогда не завершится, но в данном случае я принудительно завершаю его, как только сумма перестает расти, используя ключевое слово <b>break</b>.</p>
<p>В теле цикла я прибавляю к начальному значению суммы значение очередного члена последовательности. Затем сравниваю, изменилось ли значение суммы, по сравнению с тем, что было до суммирования, если нет, то разрываю цикл. Иначе, запоминаю значение суммы и перехожу к следующей итерации.</p>
<h4>Вычисление с заданной точностью</h4>
<p>Найти сумму ряда с точностью e = 0,001, общий член которого:</p>
<p><?=QuickStartHandler::tim(24, 3, 3) ?></p>
<p>Данный пример очень похож на предыдущий, но с той поправкой, что элемент ряда никогда не станет равен 0 и нам дано значение точности, при достижении котрого нам надо прекратить вычисления.</p>
<pre>
<b>function</b> <u title="precision - точность">precisionSum</u>() {
	<span class="strcolor">"use strict"</span>
	<b>var</b> e = 0.001,
		sum = 0, n = 1, prevSum = sum;
	<b>function</b> <u title="Программа вычисления факториала">factorial</u>(n) {
		n = <i>parseInt</i>(n);
		<b>if</b> (!n) {
			n = 0;
		}
		<b>if</b> (n < 2) {
			<b>return</b> 1;
		}
		<b>var</b> result = 1;
		<b>for</b> (<b>var</b> i = 1; i <= n; i++) {
			result = result * i;
		}
		<b>return</b> result;
	}
	<b>while</b> (<b>true</b>) {
		sum += <u title="Программа вычисления факториала">factorial</u>(n) / <u title="Программа вычисления факториала">factorial</u>(2 * n);
		n++;
		<b>if</b> (sum - prevSum <= e) {
			<b>break</b>;
		}
		prevSum = sum;
	}
	<u>writeln</u>(<span class="strcolor">'S = '</span> + sum);
}
</pre>
<p>Поэтому я вычитаю из полученного в каждой новой итерации значения суммы значение суммы, полученное на предыдущей итерации. Как только оно меньше или равно заданной нам в условии задачи точности, я заканчиваю вычисление.</p>
<p>Если не знаем, что такое n! смотрим в поисковой системе [подставьте ту, которой пользуетесь], что это такое и узнаем что это факториал. И даже, что факториал целого числа n равен произведению целых членов ряда [1 .. n] то есть все целые числа от одного до n включительно надо перемножить, тогда получим факториал.</p>
<p>Я вынес этот нехитрый алгоритм в функцию factorial и использую ее при решении основной задачи.</p>
<p>Если этот текст будут читать программисты, они наверное скажут, что неплохо бы получить факториал через рекурсивные вызовы. Но на мой взгляд эта статья и так перегружена, тем более что, то что я собираюсь сообщить в ней еще по-моему не менее важно, чем рекурсивные алгоритмы.</p>
<h4>Производительность циклов. Что неплохо знать о циклах JavaScript программисту, стремящемуся писать код грамотно</h4>
(По книге Стояна Стефанова &laquo;JavaScript. Шаблоны&raquo;)
<p>В циклах часто приходится перебирать массивы. При этом часто можно встретить в чужом коде и в том числе в коде который приводил я здесь такое определение цикла:</p>
<pre>
<b>for</b> (<b>var</b> i = 0; i < array.length; i++) { <span class="strcolor">//Для i меньшей, чем длина массива делать и увеличивать i  на единицу ... 
</span>	<span class="strcolor">//тут что-то делаем
</span>}
</pre>
<p>Масивы могут иногда быть не маленькими, то есть выполнение тела цикла может происходить тысячи или даже десятки тысяч раз.</p>
<p>Не каждый из пишуших на JavaScript знает, что пример записи выше приводит к вычислению длины массива каждый раз перед выполнением тела цикла. (Догадаться об этом и впрямь сложно, ведь length - это свойство объекта типа <b>Array</b>, а не функция, пойди угадай, что тут происходит именно вычисление, а не чтение свойства объекта).</p>
<p>Поэтому лучше так:</p>
<pre>
<b>for</b> (<b>var</b> i = 0, length = array.length; i < length; i++) { <span class="strcolor">//Вычислили длинну массива один раз
</span>	<span class="strcolor">//тут что-то делаем
</span>}
</pre>
<p>Если не имеет значения, в каком направлении обходить массив, слева направо или справо налево, то можно сделать еще лучше:</p>
<pre>
<b>for</b> (var i = array.length - 1; i >= 0; i--) { <span class="strcolor">//Будет выполняться, пока i > 0, сравнение с нулем происходит быстрее чем с любым другим числом
</span>	<span class="strcolor">//тут что-то делаем
</span>}
</pre>
<p>Также, можно использовать цикл while:</p>
<pre>
<b>var</b> i = array.length;
<b>while</b> (i--) {<span class="strcolor">//Будет выполняться, пока i > 0, сравнение с нулем происходит быстрее чем с любым другим числом
</span>	<span class="strcolor">//тут что-то делаем
</span>}
</pre>
<div class="ainfo">
	На самом деле пример
	<p><b>for</b> (<b>var</b> i = array.length - 1; i >= 0; i--)</p>
	В книге Стефанова выглядит так:
	<p><b>for</b> (<b>var</b> i = array.length; i--)</p>
	Но мой firefox с этим не согласен: требует недостающую точку с запятой. Далее, если даже её поставить,
	<p><b>for</b> (<b>var</b> i = array.length;; i--)</p>
	первая итерация приходится на несуществующий элемент массива, так как элемента с индексом равным array.length в массиве быть не может.
	Хорошо, запишем так:
	<p><b>for</b> (<b>var</b> i = array.length - 1;; i--)</p>
	В результате уходим в бесконечный цикл. В итоге получил то, что написал выше:
	<p><b>for</b> (<b>var</b> i = array.length - 1; i >= 0; i--)</p>
	А вообще, книга &laquo;JavaScript. Шаблоны&raquo; хорошая.
	Если кто-то сможет нормально выполнить цикл с определением близким к 
	<p><b>for</b> (<b>var</b> i = array.length; i--)</p>
	напишите пожалуйста в комментариях. 
</div>
<div style="width:96%">
<div class="left"><a href="<?=WEB_ROOT?>/quick_start/branching">Назад - <?=$lang['branching']?></a></div>
<div class="right"><a href="<?=WEB_ROOT?>/quick_start/strings">Далее - <?=$lang['strings']?></a></div>
<div class="clearfix"></div>
</div>
